<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTS Comparator App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
    <style>
        .spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold mb-2">TTS Comparator</h1>
            <p class="text-gray-600 dark:text-gray-400">Compare Text-to-Speech engines with parallel testing</p>
        </div>

        <!-- Input Section -->
        <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6 mb-6">
            <div class="mb-4">
                <div class="flex justify-between items-center mb-2">
                    <label class="block text-sm font-medium">Text Input &amp; Attachments</label>
                    <div class="flex gap-1">
                        <button id="copyStateBtn" class="p-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors text-xs" title="Copy state to clipboard">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button id="downloadStateBtn" class="p-1.5 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition-colors text-xs" title="Download state as JSON file">
                            <i class="fas fa-download"></i>
                        </button>
                        <button id="pasteStateBtn" class="p-1.5 bg-green-500 text-white rounded hover:bg-green-600 transition-colors text-xs" title="Load state from clipboard">
                            <i class="fas fa-paste"></i>
                        </button>
                        <button id="uploadStateBtn" class="p-1.5 bg-cyan-500 text-white rounded hover:bg-cyan-600 transition-colors text-xs" title="Upload state from JSON file">
                            <i class="fas fa-upload"></i>
                        </button>
                    </div>
                </div>
                <textarea id="inputText" class="w-full h-32 p-3 border border-gray-300 dark:border-gray-600 rounded-lg resize-none text-base bg-white dark:bg-gray-700" placeholder="Enter your text here for TTS comparison..."></textarea>
            </div>
            
            <div class="mb-4">
                <input type="file" id="fileInput" multiple="" accept=".pdf,.txt,.doc,.docx" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-white hover:file:bg-primary/90">
            </div>



            <!-- Control Buttons -->
            <div class="flex gap-3 justify-center flex-wrap">
                <button id="checkBtn" class="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors" title="Check compatibility and calculate costs">
                    <i class="fas fa-check-circle"></i>
                    Check
                </button>
                
                <button id="executeBtn" class="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors" title="Execute selected engines">
                    <i class="fas fa-play"></i>
                    Execute
                </button>
                
                <button id="selectAllBtn" class="p-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors" title="Select all engines">
                    <i class="fas fa-check-double"></i>
                </button>
                
                <button id="uncheckAllBtn" class="p-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition-colors" title="Uncheck all selections">
                    <i class="fas fa-square-check"></i>
                </button>
                
                <button id="clearAllAudioBtn" class="p-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors" title="Clear all generated audio">
                    <i class="fas fa-trash"></i>
                </button>
                
                <button id="downloadAllBtn" class="p-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors" title="Download all generated audio">
                    <i class="fas fa-download"></i>
                </button>
            </div>
        </div>

        <!-- TTS Engines Grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4" id="enginesGrid">
            <!-- Engine cards will be populated by JavaScript -->
        </div>

        <!-- Status Display -->
        <div id="statusDisplay" class="mt-6 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg hidden">
            <h3 class="font-semibold mb-2">Status:</h3>
            <div id="statusContent"></div>
        </div>

        <!-- Debug Log -->
        <div class="mt-6">
            <button id="toggleLog" class="flex items-center gap-2 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors" onclick="toggleDebugLog()">
                <i class="fas fa-terminal"></i>
                <span id="logToggleText">Show Debug Log</span>
                <i id="logToggleIcon" class="fas fa-chevron-down"></i>
            </button>
            
            <div id="debugLog" class="hidden mt-4 bg-black text-green-400 p-4 rounded-lg font-mono text-sm max-h-96 overflow-y-auto">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-green-300">Debug Log:</span>
                    <button onclick="copyLogToClipboard()" class="px-2 py-1 bg-gray-700 text-white rounded text-xs hover:bg-gray-600" title="Copy log to clipboard">
                        <i class="fas fa-copy"></i> Copy
                    </button>
                </div>
                <div id="logContent"></div>
            </div>
        </div>
    </div>



    <script>
        // TTS Engine Configurations
        const ttsEngines = {
            'ElevenLabs-v3': {
                botName: '@ElevenLabs-v3',
                cost: { type: 'per_char', rate: 2 },
                color: 'blue',
                settings: {
                    voice: ['Default', 'Sarah', 'George', 'River', 'Matilda', 'Will', 'Jessica', 'Brian', 'Lily', 'Monika Sogam'],
                    speaker_count: ['1', '2', '3', '4', '5'],
                    language: ['English', 'Hindi']
                },
                supports: ['text', 'pdf', 'multi_speaker'],
                description: 'Cutting-edge TTS with performance-level control and audio tags'
            },
            'Hailuo-Speech-02': {
                botName: '@Hailuo-Speech-02',
                cost: { type: 'per_1k_char', rate_turbo: 2000, rate_hd: 3334 },
                color: 'green',
                settings: {
                    voice: ['Default', 'Standard Voice', 'Premium Voice'],
                    language: ['English', 'Hindi', 'Chinese'],
                    pitch: ['Low', 'Normal', 'High'],
                    speed: ['Slow', 'Normal', 'Fast'],
                    volume: ['Low', 'Normal', 'High'],
                    quality: ['Turbo', 'HD']
                },
                supports: ['text'],
                description: 'High-quality TTS with language detection and HD output'
            },
            'Cartesia-Sonic': {
                botName: '@Cartesia-Sonic',
                cost: { type: 'per_1k_char', rate: 934 },
                color: 'purple',
                settings: {
                    voice: ['American Voiceover Man', 'California Girl', 'British Lady', 'Australian Woman', 'Commercial Lady', 'Friendly Reading Man'],
                    language: ['English', 'Hindi', 'Chinese', 'Spanish', 'French']
                },
                supports: ['text'],
                description: 'Sonic 2.0 TTS covering 15 languages with diverse voices'
            },
            'Unreal-Speech-TTS': {
                botName: '@Unreal-Speech-TTS',
                cost: { type: 'per_char', rate: 0.2 },
                color: 'red',
                settings: {
                    voice: ['Sierra', 'Noah', 'Jasper', 'Caleb', 'Autumn', 'Melody', 'Hannah', 'Emily', 'Benjamin', 'Arthur', 'Eleanor', 'Chloe'],
                    language: ['English', 'Hindi', 'Chinese', 'Spanish', 'French', 'Italian', 'Portuguese']
                },
                supports: ['text', 'url', 'pdf'],
                description: 'Natural speech conversion for 8 languages with multiple voices'
            },
            'PlayAI-TTS': {
                botName: '@PlayAI-TTS',
                cost: { type: 'per_second', rate: 17 },
                color: 'yellow',
                settings: {
                    voice: ['Jennifer_(English_(US)/American)', 'Dexter_(English_(US)/American)', 'Ava_(English_(AU)/Australian)', 'Tilly_(English_(AU)/Australian)', 'Cecil_(English_(GB)/British)', 'Sterling_(English_(GB)/British)'],
                    language: ['English', 'Hindi', 'French', 'German', 'Spanish']
                },
                supports: ['text'],
                description: 'PlayHT TTS with conversational and narrative voice options'
            },
            'ElevenLabs-v2.5-Turbo': {
                botName: '@ElevenLabs-v2.5-Turbo',
                cost: { type: 'per_char', rate: 1 },
                color: 'indigo',
                settings: {
                    voice: ['Jessica', 'Sarah', 'George', 'River', 'Matilda', 'Will', 'Brian', 'Lily', 'Monika Sogam', 'James Gao', 'Martin Li'],
                    language: ['English', 'Hindi', 'Chinese', 'Spanish', 'Arabic', 'German']
                },
                supports: ['text', 'url', 'pdf'],
                description: 'Leading TTS technology with Turbo v2.5 model'
            },
            'PlayAI-Dialog': {
                botName: '@PlayAI-Dialog',
                cost: { type: 'per_second', rate: 29 },
                color: 'pink',
                settings: {
                    speaker_1: ['Jennifer_(English_(US)/American)', 'Dexter_(English_(US)/American)', 'Cecil_(English_(GB)/British)', 'Sterling_(English_(GB)/British)'],
                    speaker_2: ['Ava_(English_(AU)/Australian)', 'Tilly_(English_(AU)/Australian)', 'Charlotte_(Advertising)_(English_(CA)/Canadian)', 'Madison_(English_(IE)/Irish)'],
                    language: ['English', 'Hindi', 'French', 'German']
                },
                supports: ['text', 'dialog'],
                description: 'Multi-speaker dialogue generation with voice customization'
            },
            'Orpheus-TTS': {
                botName: '@Orpheus-TTS',
                cost: { type: 'per_1k_char', rate: 1667 },
                color: 'teal',
                settings: {
                    voice: ['tara', 'leah', 'jess', 'leo', 'dan', 'mia', 'zac', 'zoe'],
                    language: ['English', 'Hindi'],
                    sound_effects: ['None', '<laugh>', '<chuckle>', '<sigh>', '<cough>', '<sniffle>', '<groan>', '<yawn>', '<gasp>', '<giggle>']
                },
                supports: ['text', 'sound_effects'],
                description: 'Llama-based Speech-LLM with empathetic TTS and sound effects'
            }
        };

        // Global state
        let generatedAudio = {};
        let selectedEngines = new Set();

        // Initialize app
        function initializeApp() {
            createEngineCards();
            setupEventListeners();
            setupDarkMode();
        }

        // Setup dark mode detection
        function setupDarkMode() {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });
        }

        // Create engine cards
        function createEngineCards() {
            const grid = document.getElementById('enginesGrid');
            
            Object.entries(ttsEngines).forEach(([engineName, config]) => {
                const card = createEngineCard(engineName, config);
                grid.appendChild(card);
            });
        }

        // Create individual engine card
        function createEngineCard(engineName, config) {
            const card = document.createElement('div');
            card.className = `bg-white dark:bg-gray-800 rounded-lg p-4 border-l-4 border-${config.color}-500 shadow-lg`;
            card.innerHTML = `
                <div class="flex items-start justify-between mb-3">
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="check-${engineName}" class="w-4 h-4 text-${config.color}-600 rounded" onchange="handleCheckboxChange('${engineName}')">
                        <h3 class="font-semibold text-sm">${engineName}</h3>
                    </div>
                    <div id="status-icon-${engineName}" class="text-gray-400">
                        <i class="fas fa-circle text-xs"></i>
                    </div>
                </div>
                
                <p class="text-xs text-gray-600 dark:text-gray-400 mb-3">${config.description}</p>
                
                <!-- Settings -->
                <div class="space-y-2 mb-3">
                    ${createSettingsDropdowns(engineName, config.settings)}
                </div>
                
                <!-- Cost -->
                <div class="mb-3">
                    <div id="cost-${engineName}" class="text-xs font-mono text-${config.color}-600">
                        Cost: 0 points
                    </div>
                </div>
                
                <!-- Persistent Audio Player -->
                <div class="mb-3">
                    <audio id="audio-${engineName}" controls class="w-full h-8">
                        <source src="" type="audio/mpeg">
                    </audio>
                </div>
                
                <!-- Download Button -->
                <button 
                    id="download-${engineName}" 
                    onclick="downloadAudio('${engineName}')" 
                    class="w-full px-2 py-1 bg-${config.color}-500 text-white rounded text-xs hover:bg-${config.color}-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled
                >
                    <i class="fas fa-download"></i> Download
                </button>
            `;
            
            return card;
        }

        // Create settings dropdowns
        function createSettingsDropdowns(engineName, settings) {
            return Object.entries(settings).map(([setting, options]) => `
                <div>
                    <label class="block text-xs font-medium mb-1 capitalize">${setting.replace('_', ' ')}</label>
                    <select id="${engineName}-${setting}" class="w-full text-xs p-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700">
                        ${options.map((option, index) => `<option value="${option}" ${index === 0 ? 'selected' : ''}>${option}</option>`).join('')}
                    </select>
                </div>
            `).join('');
        }



        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('checkBtn').addEventListener('click', checkCompatibilityAndCosts);
            document.getElementById('executeBtn').addEventListener('click', executeSelectedEngines);
            document.getElementById('selectAllBtn').addEventListener('click', selectAllEngines);
            document.getElementById('uncheckAllBtn').addEventListener('click', uncheckAllEngines);
            document.getElementById('clearAllAudioBtn').addEventListener('click', clearAllAudio);
            document.getElementById('downloadAllBtn').addEventListener('click', downloadAllAudio);
            document.getElementById('copyStateBtn').addEventListener('click', copyAppState);
            document.getElementById('downloadStateBtn').addEventListener('click', downloadAppState);
            document.getElementById('pasteStateBtn').addEventListener('click', pasteAppState);
            document.getElementById('uploadStateBtn').addEventListener('click', uploadAppState);
        }



        // Update status icon
        function updateStatusIcon(engineName, status) {
            const iconEl = document.getElementById(`status-icon-${engineName}`);
            
            switch (status) {
                case 'ready':
                    iconEl.innerHTML = '<i class="fas fa-circle text-gray-400 text-xs"></i>';
                    break;
                case 'processing':
                    iconEl.innerHTML = '<i class="fas fa-spinner spinner text-blue-500 text-xs"></i>';
                    break;
                case 'completed':
                    iconEl.innerHTML = '<i class="fas fa-check text-green-500 text-xs"></i>';
                    break;
                case 'error':
                    iconEl.innerHTML = '<i class="fas fa-times text-red-500 text-xs"></i>';
                    break;
            }
        }

        // Check compatibility and calculate costs
        function checkCompatibilityAndCosts() {
            const inputText = document.getElementById('inputText').value;
            const files = document.getElementById('fileInput').files;
            
            let compatibleCount = 0;
            let totalEstimatedCost = 0;
            
            Object.keys(ttsEngines).forEach(engineName => {
                const isCompatible = checkEngineCompatibility(engineName, inputText, files);
                const cost = calculateEngineCost(engineName, inputText);
                
                if (isCompatible) compatibleCount++;
                totalEstimatedCost += cost;
            });
            
            showStatus(`Check completed: ${compatibleCount}/8 engines compatible. Total estimated cost: ${Math.round(totalEstimatedCost)} points.`);
        }

        // Check engine compatibility
        function checkEngineCompatibility(engineName, inputText, files) {
            const config = ttsEngines[engineName];
            let compatible = true;
            
            if (!inputText && files.length === 0) {
                compatible = false;
            }
            
            if (files.length > 0 && !config.supports.includes('pdf') && !config.supports.includes('url')) {
                compatible = false;
            }
            
            return compatible;
        }

        // Calculate engine cost
        function calculateEngineCost(engineName, inputText) {
            const config = ttsEngines[engineName];
            const costEl = document.getElementById(`cost-${engineName}`);
            let cost = 0;
            
            if (!inputText) {
                costEl.textContent = 'Cost: 0 points';
                return 0;
            }
            
            const textLength = inputText.length;
            addToLog(`Calculating cost for ${engineName}: ${textLength} characters`);
            
            switch (config.cost.type) {
                case 'per_char':
                    cost = textLength * config.cost.rate;
                    addToLog(`${engineName}: ${textLength} chars × ${config.cost.rate} = ${cost} points`);
                    break;
                case 'per_1k_char':
                    const thousandCharRatio = textLength / 1000;
                    let rate = config.cost.rate;
                    
                    if (engineName === 'Hailuo-Speech-02') {
                        const quality = document.getElementById(`${engineName}-quality`)?.value || 'Turbo';
                        rate = quality === 'HD' ? config.cost.rate_hd : config.cost.rate_turbo;
                    }
                    
                    cost = thousandCharRatio * rate;
                    addToLog(`${engineName}: ${textLength}/1000 chars × ${rate} = ${cost.toFixed(2)} points`);
                    break;
                case 'per_second':
                    const estimatedSeconds = Math.ceil(textLength / 150);
                    cost = estimatedSeconds * config.cost.rate;
                    addToLog(`${engineName}: ~${estimatedSeconds} seconds × ${config.cost.rate} = ${cost} points`);
                    break;
            }
            
            costEl.textContent = `Cost: ${cost < 1 ? cost.toFixed(2) : Math.round(cost)} points`;
            return cost;
        }

        // Execute selected engines
        async function executeSelectedEngines() {
            const inputText = document.getElementById('inputText').value;
            const files = document.getElementById('fileInput').files;
            
            if (!inputText && files.length === 0) {
                showStatus('Please provide text input or file attachments');
                return;
            }
            
            const selectedEngineList = getSelectedEngines();
            if (selectedEngineList.length === 0) {
                showStatus('Please select at least one engine');
                return;
            }
            
            showStatus(`Executing ${selectedEngineList.length} engines...`);
            addToLog(`Starting execution of ${selectedEngineList.length} engines: ${selectedEngineList.join(', ')}`);
            
            // Execute each engine separately with individual settings
            selectedEngineList.forEach(engineName => {
                executeEngine(engineName, inputText, files);
            });
        }

        // Execute individual engine
        async function executeEngine(engineName, inputText, files) {
            const config = ttsEngines[engineName];
            
            updateStatusIcon(engineName, 'processing');
            
            try {
                // Build prompt with settings
                const prompt = buildPrompt(engineName, inputText);
                
                // Register handler for this engine
                if (window.Poe && window.Poe.registerHandler) {
                    window.Poe.registerHandler(`tts-${engineName}`, (result, context) => {
                        handleTTSResponse(engineName, result);
                    });
                    
                    // Send message to bot
                    const messageOptions = {
                        handler: `tts-${engineName}`,
                        stream: false,
                        openChat: false,
                        handlerContext: { engine: engineName }
                    };
                    
                    if (files.length > 0) {
                        messageOptions.attachments = Array.from(files);
                    }
                    
                    await window.Poe.sendUserMessage(prompt, messageOptions);
                } else {
                    // Fallback for testing without Poe API
                    setTimeout(() => {
                        updateStatusIcon(engineName, 'completed');
                        showAudioInPlayer(engineName, 'demo-audio.mp3');
                    }, 2000 + Math.random() * 3000);
                }
                
            } catch (error) {
                updateStatusIcon(engineName, 'error');
                addToLog(`${engineName}: Error - ${error.message}`);
            }
        }

        // Build prompt with settings
        function buildPrompt(engineName, inputText) {
            const config = ttsEngines[engineName];
            let prompt = `${config.botName} ${inputText}`;
            
            // Add engine-specific parameters
            Object.keys(config.settings).forEach(setting => {
                const value = document.getElementById(`${engineName}-${setting}`)?.value;
                if (value && value !== 'Default' && value !== 'None') {
                    if (setting === 'voice' || setting === 'speaker_1' || setting === 'speaker_2') {
                        prompt += ` --${setting} ${value}`;
                    } else if (setting === 'quality' && value === 'HD') {
                        prompt += ` --hd`;
                    } else if (setting === 'language' && value !== 'English') {
                        const langCode = getLanguageCode(value);
                        if (langCode) prompt += ` --language ${langCode}`;
                    } else {
                        prompt += ` --${setting} ${value}`;
                    }
                }
            });
            
            return prompt;
        }

        // Get language code
        function getLanguageCode(language) {
            const codes = {
                'Hindi': 'hi',
                'Marathi': 'mr',
                'Chinese': 'zh',
                'Spanish': 'es',
                'French': 'fr',
                'German': 'de',
                'Italian': 'it',
                'Portuguese': 'pt',
                'Arabic': 'ar'
            };
            return codes[language] || null;
        }

        // Handle TTS response
        function handleTTSResponse(engineName, result) {
            if (result.status === 'error') {
                updateStatusIcon(engineName, 'error');
                addToLog(`${engineName}: Error - ${result.responses[0]?.statusText || 'Unknown error'}`);
                return;
            }
            
            if (result.status === 'complete') {
                const response = result.responses[0];
                if (response?.attachments?.length > 0) {
                    const audioAttachment = response.attachments[0];
                    updateStatusIcon(engineName, 'completed');
                    showAudioInPlayer(engineName, audioAttachment.url);
                    generatedAudio[engineName] = {
                        url: audioAttachment.url,
                        name: audioAttachment.name
                    };
                } else {
                    updateStatusIcon(engineName, 'error');
                    addToLog(`${engineName}: No audio generated`);
                }
            }
        }

        // Show audio in player
        function showAudioInPlayer(engineName, audioUrl) {
            const audioEl = document.getElementById(`audio-${engineName}`);
            const downloadBtn = document.getElementById(`download-${engineName}`);
            
            addToLog(`${engineName}: Setting audio URL: ${audioUrl}`);
            
            // Set audio source
            audioEl.src = audioUrl;
            audioEl.load();
            
            // Enable download button
            downloadBtn.disabled = false;
            
            // Add error handling
            audioEl.onerror = function() {
                addToLog(`${engineName}: Audio loading error`);
                updateStatusIcon(engineName, 'error');
            };
            
            // Add loaded event
            audioEl.onloadeddata = function() {
                addToLog(`${engineName}: Audio loaded successfully`);
            };
        }

        // Clear single audio
        function clearSingleAudio(engineName) {
            const audioEl = document.getElementById(`audio-${engineName}`);
            const downloadBtn = document.getElementById(`download-${engineName}`);
            
            // Clear audio
            audioEl.src = '';
            audioEl.load();
            
            // Disable download button
            downloadBtn.disabled = true;
            
            // Reset status
            updateStatusIcon(engineName, 'ready');
            
            // Remove from generated audio
            delete generatedAudio[engineName];
            
            addToLog(`${engineName}: Audio cleared`);
        }

        // Clear all audio
        function clearAllAudio() {
            Object.keys(ttsEngines).forEach(engineName => {
                clearSingleAudio(engineName);
            });
            showStatus('All audio cleared');
        }

        // Get selected engines
        function getSelectedEngines() {
            return Object.keys(ttsEngines).filter(engineName => 
                document.getElementById(`check-${engineName}`).checked
            );
        }

        // Select all engines
        function selectAllEngines() {
            Object.keys(ttsEngines).forEach(engineName => {
                document.getElementById(`check-${engineName}`).checked = true;
                selectedEngines.add(engineName);
            });
            addToLog('All engines selected');
        }

        // Uncheck all engines
        function uncheckAllEngines() {
            Object.keys(ttsEngines).forEach(engineName => {
                document.getElementById(`check-${engineName}`).checked = false;
                selectedEngines.delete(engineName);
            });
            addToLog('All engines unchecked');
        }

        // Download individual audio
        function downloadAudio(engineName) {
            const audio = generatedAudio[engineName];
            if (!audio) return;
            
            const fileName = generateFileName(engineName, audio.name);
            downloadFile(audio.url, fileName);
        }

        // Download all audio
        function downloadAllAudio() {
            const audioCount = Object.keys(generatedAudio).length;
            if (audioCount === 0) {
                showStatus('No audio to download');
                return;
            }
            
            Object.keys(generatedAudio).forEach(engineName => {
                downloadAudio(engineName);
            });
            
            showStatus(`Downloaded ${audioCount} audio files`);
        }

        // Generate file name
        function generateFileName(engineName, originalName) {
            const now = new Date();
            const month = now.toLocaleString('default', { month: 'long' });
            const date = now.getDate();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            
            const extension = originalName ? originalName.split('.').pop() : 'mp3';
            
            return `${engineName}_${month}${date}_${hours}${minutes}${seconds}.${extension}`;
        }

        // Download file
        function downloadFile(url, fileName) {
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Show status message
        function showStatus(message) {
            const statusDisplay = document.getElementById('statusDisplay');
            const statusContent = document.getElementById('statusContent');
            
            statusContent.textContent = message;
            statusDisplay.classList.remove('hidden');
            
            setTimeout(() => {
                statusDisplay.classList.add('hidden');
            }, 3000);
        }

        // Debug logging system
        let debugLogs = [];
        
        function addToLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            debugLogs.push(`[${timestamp}] ${message}`);
            updateLogDisplay();
        }
        
        function updateLogDisplay() {
            const logContent = document.getElementById('logContent');
            if (logContent) {
                logContent.innerHTML = debugLogs.map(log => `<div class="mb-1">${log}</div>`).join('');
                logContent.scrollTop = logContent.scrollHeight;
            }
        }
        
        function toggleDebugLog() {
            const debugLog = document.getElementById('debugLog');
            const toggleText = document.getElementById('logToggleText');
            const toggleIcon = document.getElementById('logToggleIcon');
            
            if (debugLog.classList.contains('hidden')) {
                debugLog.classList.remove('hidden');
                toggleText.textContent = 'Hide Debug Log';
                toggleIcon.className = 'fas fa-chevron-up';
            } else {
                debugLog.classList.add('hidden');
                toggleText.textContent = 'Show Debug Log';
                toggleIcon.className = 'fas fa-chevron-down';
            }
        }
        
        function copyLogToClipboard() {
            const logText = debugLogs.join('\n');
            navigator.clipboard.writeText(logText).then(() => {
                showStatus('Log copied to clipboard');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = logText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus('Log copied to clipboard');
            });
        }

        // Handle checkbox state changes
        function handleCheckboxChange(engineName) {
            const isChecked = document.getElementById(`check-${engineName}`).checked;
            addToLog(`${engineName}: Checkbox ${isChecked ? 'checked' : 'unchecked'}`);
            
            // Update selectedEngines set for better tracking
            if (isChecked) {
                selectedEngines.add(engineName);
            } else {
                selectedEngines.delete(engineName);
            }
        }

        // Get complete app state
        function getAppState() {
            const state = {
                inputText: document.getElementById('inputText').value,
                selectedEngines: Array.from(selectedEngines),
                engineSettings: {},
                debugLog: debugLogs.slice(),
                timestamp: new Date().toISOString()
            };
            
            // Save all engine settings
            Object.keys(ttsEngines).forEach(engineName => {
                const engineConfig = ttsEngines[engineName];
                state.engineSettings[engineName] = {};
                
                Object.keys(engineConfig.settings).forEach(setting => {
                    const element = document.getElementById(`${engineName}-${setting}`);
                    if (element) {
                        state.engineSettings[engineName][setting] = element.value;
                    }
                });
                
                // Save checkbox state
                const checkbox = document.getElementById(`check-${engineName}`);
                state.engineSettings[engineName].checked = checkbox.checked;
            });
            
            return state;
        }

        // Apply app state
        function applyAppState(state) {
            // Restore input text
            if (state.inputText) {
                document.getElementById('inputText').value = state.inputText;
            }
            
            // Clear current selections
            selectedEngines.clear();
            
            // Restore engine settings
            Object.keys(ttsEngines).forEach(engineName => {
                if (state.engineSettings && state.engineSettings[engineName]) {
                    const engineState = state.engineSettings[engineName];
                    
                    // Restore dropdown values
                    Object.keys(ttsEngines[engineName].settings).forEach(setting => {
                        const element = document.getElementById(`${engineName}-${setting}`);
                        if (element && engineState[setting]) {
                            element.value = engineState[setting];
                        }
                    });
                    
                    // Restore checkbox state
                    const checkbox = document.getElementById(`check-${engineName}`);
                    if (checkbox && engineState.checked !== undefined) {
                        checkbox.checked = engineState.checked;
                        if (engineState.checked) {
                            selectedEngines.add(engineName);
                        }
                    }
                }
            });
            
            // Restore debug log
            if (state.debugLog && Array.isArray(state.debugLog)) {
                debugLogs = state.debugLog.slice();
                updateLogDisplay();
            }
        }

        // Copy state to clipboard
        function copyAppState() {
            const state = getAppState();
            const stateJSON = JSON.stringify(state, null, 2);
            
            navigator.clipboard.writeText(stateJSON).then(() => {
                addToLog('App state copied to clipboard');
                showStatus('State copied to clipboard');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = stateJSON;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                addToLog('App state copied to clipboard (fallback)');
                showStatus('State copied to clipboard');
            });
        }

        // Download state as file
        function downloadAppState() {
            const state = getAppState();
            const stateJSON = JSON.stringify(state, null, 2);
            
            const blob = new Blob([stateJSON], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
            const fileName = `TTS_Config_${timestamp}.json`;
            
            downloadFile(url, fileName);
            URL.revokeObjectURL(url);
            
            addToLog(`App state downloaded as ${fileName}`);
            showStatus('State downloaded successfully');
        }

        // Paste state from clipboard (modal)
        function pasteAppState() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-2xl w-full mx-4 max-h-96">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Load State from JSON</h3>
                        <button class="text-gray-500 hover:text-gray-700" onclick="this.closest('.fixed').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <textarea 
                        id="stateInput" 
                        class="w-full h-48 p-3 border border-gray-300 dark:border-gray-600 rounded-lg resize-none text-sm bg-white dark:bg-gray-700 font-mono"
                        placeholder="Paste your JSON state here..."
                    ></textarea>
                    <div class="flex justify-end space-x-3 mt-4">
                        <button class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded" onclick="this.closest('.fixed').remove()">Cancel</button>
                        <button class="px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded" onclick="loadStateFromModal()">Load State</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus textarea
            setTimeout(() => document.getElementById('stateInput').focus(), 100);
            
            // Add global function for loading
            window.loadStateFromModal = function() {
                const stateJSON = document.getElementById('stateInput').value.trim();
                if (!stateJSON) {
                    showStatus('Please enter JSON state');
                    return;
                }
                
                try {
                    const state = JSON.parse(stateJSON);
                    applyAppState(state);
                    addToLog('App state loaded from clipboard');
                    showStatus('State loaded successfully');
                    modal.remove();
                } catch (error) {
                    addToLog(`Error loading state from clipboard: ${error.message}`);
                    showStatus('Invalid JSON format');
                }
            };
        }

        // Upload state from file
        function uploadAppState() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const state = JSON.parse(e.target.result);
                        applyAppState(state);
                        addToLog(`App state loaded from ${file.name}`);
                        showStatus('State uploaded successfully');
                    } catch (error) {
                        addToLog(`Error loading state from file: ${error.message}`);
                        showStatus('Error loading state file');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Initialize the app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            addToLog('TTS Comparator App initialized');
        });
    </script>


</body></html>